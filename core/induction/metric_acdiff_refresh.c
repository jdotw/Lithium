#include <stdlib.h>
#include <string.h>

#include "induction.h"
#include "list.h"
#include "timer.h"
#include "timeutil.h"
#include "cement.h"
#include "entity.h"
#include "container.h"
#include "object.h"
#include "metric.h"

/* 
 * Automatically Calculated Metrics - Difference
 */

/* Metric refresh function
 *
 * The REFOP_REFRESH is usually generated by the 
 * i_metric_acdiff_refcb refresh callback that
 * is fired when the either x or y derivitive 
 * metrics are refreshed
 */

/** @addtogroup metric_acdiff Difference Metric
 * @ingroup metric
 * @{
 */

int i_metric_acdiff_refresh (i_resource *self, i_metric *diffmet, int opcode)
{
  int num;
  double xflt;
  double yflt;
  double valflt;
  i_metric_value *xval;
  i_metric_value *yval;
  i_metric_value *diffval;
  i_metric_acdiff_data *data = diffmet->refresh_data;

  switch (opcode & REFOP_ALL)
  {
    case REFOP_REFRESH:
      /*
       * This OP always returns 1 to signify that the 
       * refresh has already finished
       */

      /* Check the refresh_result of both the xmet and
       * the ymet (if present). 
       * If either one is not set to REFRESULT_OK
       * then set the diffmet->refresh_result to that
       * result and exit.
       */

      if (data->xmet->refresh_result != REFRESULT_OK)
      { diffmet->refresh_result = data->xmet->refresh_result; return 1; }
      if (data->ymet && data->ymet->refresh_result != REFRESULT_OK)
      { diffmet->refresh_result = data->ymet->refresh_result; return 1; }

      /* At this point, the refresh_result for 
       * both the xmet and ymet must be REFRESULT_OK
       * Hence, set our result accordingly
       */
      diffmet->refresh_result = REFRESULT_OK;

      /* Retrieve and check for current xmet and ymet values */
      xval = i_metric_curval (data->xmet);
      if (data->ymet)
      {
        /* Retrieve value from ymet */
        yval = i_metric_curval (data->ymet);
      }
      else
      {
        /* Retrieve second most recent value from xmet (no ymet specified) */
        i_list_move_head (data->xmet->val_list);
        i_list_move_next (data->xmet->val_list);
        yval = i_list_restore (data->xmet->val_list);
      }
      if (!xval || !yval)
      { 
        /* No xval and/or yval - can not compute */
        diffmet->refresh_result = REFRESULT_TOTAL_FAIL; 
        return 1; 
      }

      /* Convert xval and yval to floating point values */
      xflt = i_metric_valflt (data->xmet, xval);
      if (data->ymet)
      { yflt = i_metric_valflt (data->ymet, yval); }
      else
      { yflt = i_metric_valflt (data->xmet, yval); }

      /* Create the value */
      diffval = i_metric_value_create ();

      /* Calculate the value */
      valflt = xflt - yflt;

      /* Set the value of diffval using
       * the calculated valflt
       */
      num = i_metric_valflt_set (diffmet, diffval, valflt);
      if (num != 0)
      {
        i_printf (2, "i_metric_acdiff_refresh failed to convert calculated floating point value to a metric value for %s %s",
          i_entity_typestr (diffmet->ent_type), diffmet->name_str);
        i_metric_value_free (diffval);
        diffmet->refresh_result = REFRESULT_TOTAL_FAIL;
        return 1;
      }

      /* Enqueue metric */
      num = i_metric_value_enqueue (self, diffmet, diffval);
      if (num != 0)
      {
        i_printf (1, "i_metric_acdiff_refresh failed to enqueue value to %s %s",
          i_entity_typestr (diffmet->ent_type), diffmet->name_str);
        i_metric_value_free (diffval);
        diffmet->refresh_result = REFRESULT_TOTAL_FAIL;
        return 1;
      }

      return 1;

    case REFOP_TERMINATE:
      break;
    case REFOP_CLEANDATA:
      i_metric_acdiff_data_free (diffmet->refresh_data);
      diffmet->refresh_data = NULL;
      break;
    default:
      i_printf (1, "i_metric_acdiff_refresh received unsupported refresh opcode %i for %s %s", 
        opcode, i_entity_typestr(diffmet->ent_type), diffmet->name_str);
  }

  return 0;
}
