#include <stdlib.h>
#include <string.h>

#include "induction.h"
#include "list.h"
#include "timer.h"
#include "timeutil.h"
#include "cement.h"
#include "entity.h"
#include "container.h"
#include "object.h"
#include "metric.h"

/** \addtogroup metric_acvol Volume Metric
 * @ingroup metric
 * @{
 */

/* 
 * Automatically Calculated Metrics - Volume
 */

/* Metric refresh function
 *
 * The REFOP_REFRESH is usually generated by the 
 * i_metric_acvol_countrefcb refresh callback that
 * is fired whe the derivitive counter metric is refreshed
 */

int i_metric_acvol_refresh (i_resource *self, i_metric *volmet, int opcode)
{
  int num;
  unsigned long diff;
//  time_t discont_time;              /* Epoch time of last discontinuity */
  i_metric_value *curcountval;
  i_metric_value *prevcountval;
  i_metric_value *prevvolval;       /* Previous (current until new val is enqueued) volume value */
  i_metric_value *volval;
//  i_metric_value *uptimeval;
//  i_metric_value *discontval;
  i_metric_acvol_data *data = volmet->refresh_data;

  switch (opcode & REFOP_ALL)
  {
    case REFOP_REFRESH:
      /* Set Refresh Value to be the
       * refresh value of the counter metric. 
       * If the counter metrics refresh result is not
       * REFRESULT_OK, then there cant be a new value to 
       * calculate a vol from.
       *
       * This OP always returns 1 to signify that the 
       * refresh has already finished
       */
      volmet->refresh_result = data->countmet->refresh_result;
      if (volmet->refresh_result != REFRESULT_OK)
      { return 1; }

      /* Retrieve cur/prev counter values if
       * a current and previous value can not
       * be retrieved, the func will exit.
       */
      i_list_move_head (data->countmet->val_list);
      curcountval = i_list_restore (data->countmet->val_list);
      i_list_move_next (data->countmet->val_list);
      prevcountval = i_list_restore (data->countmet->val_list);
      if (!curcountval || !prevcountval)
      { volmet->refresh_result = REFRESULT_TOTAL_FAIL; return 1; }

      /* Check to make sure that a new curcontval really
       * is present (i.e isnt the last one we used)
       */
      if (data->lastcurcountval == curcountval)
      { volmet->refresh_result = REFRESULT_OK; return 1; }
      data->lastcurcountval = curcountval;

      /* Create the value */
      volval = i_metric_value_create ();

      /* Calculate the last point of counter 
       * discontinuity. uptimeval.tv_sec is the 
       * number of seconds that the device has been
       * operational for. discontval.tv_sec (if present)
       * is the number of seconds into that devices 
       * operation that discontinuity occurred. Hence, the 
       * last point of discontinuity is the last time 
       * the device was reset (uptimeval->tstamp - uptimeval->tv.tv_sec)
       * plus the value of discontval.tv_sec
       *
       * NOTE: See below about discont checking being disabled
       */
//      uptimeval = i_metric_curval (data->uptimemet);
//      discontval = i_metric_curval (data->discontmet); 
//      if (uptimeval) discont_time = uptimeval->tstamp.tv_sec - uptimeval->tv.tv_sec;
//      else discont_time = 0;
//      if (discontval) discont_time += discontval->tv.tv_sec;

      /* Calculate the diff value.
       *
       * If the curcount < prevcount or the point of discontinuity
       * is AFTER the timestamp of the prevcount, then the entire 
       * value of curcountval is used. (I.e counters are discontinuous).
       * Otherwise, the diff value is curcountval - prevcountval
       *
       * NOTE: Discontinuity check is disabled and commented out in 
       *        favour of just comparing the counter values. The SNMP
       *        mib doesnt dictate that counters MUST be reset to 0
       *        on system init. ucd-snmp implementations retain
       *        the systems octet counts but reset the uptime at 
       *        each daemon re-initialisation. This caused gross errors
       *        in volume calculation where the snmp daemon is restarted
       *        without the ifcounters being reset.
       *
       *        if (curcountval->count < prevcountval->count || discont_time > prevcountval->tstamp.tv_sec)
       */
      if (curcountval->count < prevcountval->count)
      { diff = curcountval->count; }
      else
      { diff = curcountval->count - prevcountval->count; }

      /* If the time at which the last volume value was calculated
       * and the time in which this volume value is being calculated
       * (now) is in the same 'period' according to the metrics 
       * val_period, then the value of the last volume value is
       * added to the new volume value
       */
      prevvolval = i_metric_curval (volmet);
      if (prevvolval)
      {
        num = i_metric_period_validate (volmet, prevvolval->tstamp.tv_sec, volval->tstamp.tv_sec);
        if (num == 0)
        {
          /* Period is valid, add the value of prevvolval to the new valvol */
          volval->gauge = prevvolval->gauge;
        }
        else
        {
          /* Period is not valid, new volval is to begin at 0. 
           * Because the period is no longer valid, the data->remain 
           * should also be zeroed
           */
          data->remain = 0;
        }
      }

      /* Add the diff, divided by the alloc_unit value to the
       * volval->gauge variable. Any remainder from the 
       * diff/alloc_unit calc is added to the data->remain
       * variable. data->remain is then checked to see if it has
       * reached a value high enough to by syphoned off into
       * the volval->gauge value
       */
      /* Add diff / alloc_unit to volval->gauge */
      volval->gauge += diff / volmet->alloc_unit;

      /* Add the remainder from diff / alloc_unit to data->remain */
      data->remain += diff % volmet->alloc_unit;

      /* Syphon any whole-alloc-units off from data->remain */
      volval->gauge += data->remain / volmet->alloc_unit;
      data->remain %= volmet->alloc_unit;

      /* Enqueue metric */
      num = i_metric_value_enqueue (self, volmet, volval);
      if (num != 0)
      {
        i_printf (1, "i_metric_acvol_refresh failed to enqueue value to %s %s",
          i_entity_typestr (volmet->ent_type), volmet->name_str);
        i_metric_value_free (volval);
        volmet->refresh_result = REFRESULT_TOTAL_FAIL;
        return 1;
      }

      return 1;

    case REFOP_TERMINATE:
      break;
    case REFOP_CLEANDATA:
      i_metric_acvol_data_free (volmet->refresh_data);
      volmet->refresh_data = NULL;
      break;
    default:
      i_printf (1, "i_metric_acvol_refresh received unsupported refresh opcode %i for %s %s", 
        opcode, i_entity_typestr(volmet->ent_type), volmet->name_str);
  }

  return 0;
}

/* @} */
