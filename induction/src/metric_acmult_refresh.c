#include <stdlib.h>
#include <string.h>

#include "induction.h"
#include "list.h"
#include "timer.h"
#include "timeutil.h"
#include "cement.h"
#include "entity.h"
#include "container.h"
#include "object.h"
#include "metric.h"

/* 
 * Automatically Calculated Metrics - Multiply
 */

/* Metric refresh function
 *
 * The REFOP_REFRESH is usually generated by the 
 * i_metric_acmult_refcb refresh callback that
 * is fired when any of the derivitive 
 * metrics are refreshed
 */

/** @addtogroup metric_acmult Multiplier Metric
 * @ingroup metric
 * @{
 */

int i_metric_acmult_refresh (i_resource *self, i_metric *multmet, int opcode)
{
  int num;
  double valflt;
  double xflt;
  i_metric *xmet;
  i_metric_value *xval;
  i_metric_value *multval;
  i_metric_acmult_data *data = multmet->refresh_data;

  switch (opcode & REFOP_ALL)
  {
    case REFOP_REFRESH:
      /*
       * This OP always returns 1 to signify that the 
       * refresh has already finished
       */

      /* Set refresh result to a default of REFRESULT_OK
       * If no other errors occur, this result will remain
       */
      multmet->refresh_result = REFRESULT_OK;

      /* Initialise the valflt */
      valflt = 1;

      /* Loop through each derivitive metric */
      for (i_list_move_head(data->met_list); (xmet=i_list_restore(data->met_list))!=NULL; i_list_move_next(data->met_list))
      {
        /* Check the refresh_result of the derivitive
         * metric. If it is not set to REFRESULT_OK
         * then set the multmet->refresh_result to that
         * result and exit
         */
        if (xmet->refresh_result != REFRESULT_OK)
        { multmet->refresh_result = xmet->refresh_result; return 1; }

        /* Retrieve current xmet value. If no
         * value is retrieved, the refresh_result 
         * for the mult metric is set to REFRESULT_TOTAL_FAIL
         * and the func will exit
         */
        xval = i_metric_curval (xmet);
        if (!xval)
        { multmet->refresh_result = REFRESULT_TOTAL_FAIL; return 1; }

        /* Convert xval to floating point value */
        xflt = i_metric_valflt (xmet, xval);

        /* Multiply valflt by xflt */
        valflt *= xflt;
      }

      /* Create the value */
      multval = i_metric_value_create ();

      /* Set the value of multval using
       * the calculated valflt
       */
      num = i_metric_valflt_set (multmet, multval, valflt);
      if (num != 0)
      {
        i_printf (1, "i_metric_acmult_refresh failed to convert calculated floating point value to a metric value for %s %s",
          i_entity_typestr (multmet->ent_type), multmet->name_str);
        i_metric_value_free (multval);
        multmet->refresh_result = REFRESULT_TOTAL_FAIL;
        return 1;
      }

      /* Enqueue value */
      num = i_metric_value_enqueue (self, multmet, multval);
      if (num != 0)
      {
        i_printf (1, "i_metric_acmult_refresh failed to enqueue value to %s %s",
          i_entity_typestr (multmet->ent_type), multmet->name_str);
        i_metric_value_free (multval);
        multmet->refresh_result = REFRESULT_TOTAL_FAIL;
        return 1;
      }

      return 1;

    case REFOP_TERMINATE:
      break;
    case REFOP_CLEANDATA:
      i_metric_acmult_data_free (multmet->refresh_data);
      multmet->refresh_data = NULL;
      break;
    default:
      i_printf (1, "i_metric_acmult_refresh received unsupported refresh opcode %i for %s %s", 
        opcode, i_entity_typestr(multmet->ent_type), multmet->name_str);
  }

  return 0;
}
